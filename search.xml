<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[python按指定分隔符读取文件]]></title>
      <url>%2Fprogramming%2Fblockread-python.html</url>
      <content type="text"><![CDATA[在处理一些结构化的文件，如fasta文件，我们往往需要读完一条记录再进行处理，如计算每条序列的长度，GC含量等等。这个时候通常的做法是按行读，先把内容存在一个临时变量，直到读到下一个区块分隔符（如fasta文件的‘&gt;‘）的时候再处理上一条记录。如果文件不大，也可以一次读进内存，然后用split分割。前一种方法逻辑有点绕，而且容易忘记处理最后一条记录。而后一种方法对于大文件的处理就不适用了。 有没有什么方法让python以指定的分隔符读文件，而不是默认的换行符呢？我们知道perl有内建的$/变量来修改perl的默认文件分隔符，如设置$/=&#39;&gt;&#39;后，perl就可以每次读一条fasta记录。但是据我了解，python并没有类似的内建方法。这里提供一个十分方便的函数来按指定分隔符读文件： 123456789101112def blockread(fh, sep): buf = "" while True: while sep in buf: pos = buf.index(sep) yield buf[:pos] buf = buf[pos + len(sep):] chunk = fh.read(4096) if not chunk: yield buf break buf += chunk 函数第一个参数为文件句柄，第二个参数为分隔符。如果我们想遍历一个fasta文件，每次读一条fasta记录，可以使用for each in blockread(open(&#39;filename&#39;), &#39;&gt;&#39;):。该函数主要是用到yield来生成一个可迭代对象。函数的分隔符需要是字符串，经过简单修改，也可以用正则表达式作为分隔符。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[群体模拟软件ms使用说明]]></title>
      <url>%2FPopulation-Genetics%2Fms-simulation.html</url>
      <content type="text"><![CDATA[ms是中性进化条件下，群体数据模拟最常用的软件。群体数据模拟在群体遗传学研究中非常重要，可以用来评估各统计量的可靠性，研究某种群体历史下各统计量的估计值，帮助我们理解真实数据所经历的群体历史。 基本用法： 1ms nsam nreps -t θ nsam为模拟的样本数量(单倍型)，nreps为模拟的DNA片段数量，各片段之间不存在连锁。这两个参数为必需的。θ为突变参数，θ=4N0μL，详见下面参数解释。 输出文件如下： 12345678910111213141516ms 4 2 -t 5.027473 36154 10290//segsites: 4positions: 0.0110 0.0765 0.6557 0.75710010010000001001//segsites: 5positions: 0.0491 0.2443 0.2923 0.5984 0.831200001000000001011110 第一行为命令行。第二行为随机数种子，用该随机数种子可以重复模拟的结果。之后的数据以‘//’分隔各DNA片段。每个片段第一部分为分离位点数。第二部分为这些分离位点的相对位置，0～1之间，默认保留4位小数，可以用-p n 来修改精度，n为保留的小数位数。第三部分为基因型，每一行为一个单倍型，祖先型用0表示，突变用1表示。 各参数含义123456789101112131415161718192021222324-f filename # 参数文件，ms可以从文件读取除nsam, nreps之外的其它参数-seeds x1 x2 x3 # 随机数种子，3个整数，一样的随机数种子可以重复结果，缺省后ms使用默认随机数种子-t θ # 突变率，θ=4NμL, N为二倍体群体大小, μ为突变率，L为模拟的DNA片段长度。-s int # 每个DNA片段生成固定的分离位点数，如果我们要模拟不连锁的SNPs，可以设置-s 1。-T # 输出系统发育树，newick格式。-L # 输出最近共同祖先的时间及总枝长，单位是4N generation。-p int # 保留小数位数，默认是4-r ρ nsites # ρ=4Nr，r为模拟DNA片段两末端之间的重组率，nsites为DNA片段长度。-c f λ # 基因转换, f=g/r, g为每碱基转换率，如果r=0，则f=4Ng，λ为平均基因转换长度，即使ρ=0，nsites也要通过-c指定。-G α # 将所有群体的增长率设为α，群体呈指数增长，α为自然数e的幂。时间的单位为4N generation。-I npop n1 n2 ...[4Nm] # 设定一共npop个群体，每个群体的样本数分别为n1，n2 ...，群体的总基因流为4Nm，默认为0。注意，每个群体之间的基因流为4Nm/(npop-1)。 -n i x # 设置第i个群体大小为x*N。 -g i a_i # 设置第i个群体的增长率为a_i。 -m i j Mij # 设置群体j到群体i的基因流为Mij，单位为4N generation。 -ma M11, M12...M21, M22... # 设置基因流矩阵。i=j的时候，是没有任何意义的，ms会忽略，可以用x代替。-eG t a # 设置时间t的时候，所有群体的增长率，注意ms模拟的逻辑是backward，所有的时间都是距离当前的时间，单位为4N generation。-eg t i ai # 设置时间t的时候，i群体的增长率为ai。-eN t x # 设置时间t的时候，所有群体的大小为x*N，注意，此设置默认效果是所有群体的增长率变为0。因此，要使同一时间的增长率生效，增长率设置要在群体大小设置之后。-en t i x # 设置i亚群的增长率，效果同上。-eM t x # 设置t时间所有群体之间的基因流为x/(npop-1)。-em t i j x # 设置时间t，j 到i的基因流4Nmij=x。-ema t npop M11, M12... # 设置t时间的基因流矩阵。-es t i p # t时间i群体分为i和npop+1两个亚群，i中每个个体分到新i的概率为p，分到npop+1的概率为1-p。新群体的基因流和增长率都为0，群体大小设为N，i群体的基因流增长率不变。从正向历史来看，这是一个admixture事件。-ej t i j # t时间，i群体所有个体合并到j群体，i群体到其它群体的基因流都变为0，增长率不变。从正向历史来看，这是一个群体分化事件。 注: 以上N皆指 N0， 因为在markdown的代码块里面，html标记不生效 例子1. 群体大小瞬间收缩然后指数扩增 图中N1=10,000，N2=5,000，N3=20,000，如果突变率为每代10-8，如果模拟的DNA片段长度为8,000 bp，将N0设置为20,000，则θ=4*20000*10-8*8000=6.40，如果T1是16000代，则转为4N0代单位为16000/(4*20000)=0.2，T2为24000代，即0.3以4N0代为单位。5000=20000*exp-a0.2，算出a为6.93。如果该群体取15个样本，模拟1000个DNA片段，ms命令如下：1ms 15 1000 -t 6.4 -G 6.93 -eG 0.2 0.0 -eN 0.3 0.5 2. 两个群体分化后经历不同的群体大小变化 各个参数的计算参考1，不再赘述，只给每个模型的ms命令。 12ms 15 100 -t 11.2 -I 2 3 12 -g 1 44.36 -n 2 0.125 -eg 0.03125 10.0 -en 0.0625 2 0.05 -ej 0.09375 2 1 3. 近期隔离的踏脚石模型 123ms 15 100 -t 3.0 -I 6 0 7 0 0 8 0 -m 1 2 2.5 -m 2 1 2.5 -m 2 3 2.5-m 3 2 2.5 -m 4 5 2.5 -m 5 4 2.5 -m 5 6 2.5 -m 6 5 2.5 -em 2.0 3 42.5 -em 2.0 4 3 2.5 4. 近期Admixture事件 1234567891011ms 76 50000 -s 1 -I 17 24 22 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \-n 1 1 -n 2 0.3333 -n 3 0.25 -n 4 0.25 -n 5 0.2 -n 6 0.2 -n 7 0.2 -n 8 0.2 \-n 9 0.2 -n 10 0.2 -n 11 0.2 -n 12 0.2 -n 13 0.2 -n 14 0.2 -n 15 0.2 \-n 16 0.2 -n 17 0.2 \-es 0.0003125 5 0.5 -en 0.0003125 5 0.2 -ej 0.0003125 18 2 \-es 0.0003125 6 0.5 -en 0.0003125 6 0.2 -ej 0.0003125 19 2 \-ej 0.01041667 6 5 -ej 0.01041667 7 5 -ej 0.01041667 8 5 -ej 0.01041667 9 5 \-ej 0.01041667 10 5 -ej 0.01041667 11 5 -ej 0.01041667 12 5 \-ej 0.01041667 13 5 -ej 0.01041667 14 5 -ej 0.01041667 15 5 \-ej 0.01041667 16 5 -ej 0.01041667 17 5 -ej 0.01354167 5 4 \-ej 0.01458333 4 3 -ej 0.015625 3 2 -ej 0.034375 2 1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[主成分分析及其解读]]></title>
      <url>%2FPopulation-Genetics%2Fpca-interpret.html</url>
      <content type="text"><![CDATA[主成分分析是群体遗传学中常用的分析手段，一般用来 1)分析群体中存在的群体结构(分层)； 2) 推断群体历史； 3) 关联分析中对群体结构进行校正。目前用于主成分分析的数据主要为高密度的SNP标记，其主要思想是将多个线性相关的变量(SNP)，通过一系列矩阵转换，变成少数几个变异解释度大的线性无关变量(特征向量)。 主成分分析软件 主成分分析的软件非常多，R中的prcomp函数即可进行。但是对于群体遗传学中多样本(几百甚至几千)，高密度SNP标记（几百万）需要太多内存和时间，甚至根本不能完成。这里推荐两个比较好用的软件smartpca(EIGENSOFT软件包中)和flashpca。下面以smartpca为例简单说明一下主成分分析。 主成分分析过程中，基因型数据要转换为[0, 1, 2]离散变量，表示某样本某位点相对参考序列突变allele数，因此只能分析二倍体双等位基因数据(smartpca也可以分析SSR数据)。n个样本，m个SNPs，既生成n x m矩阵。smartpca在计算过程中，每列需要标准化，即矩阵中每个数字要减去该列平均数uj，同时除以uj的一个函数，因此每列的和为0，自由度变为n-1，所以smartpca算出来的特征值和特征向量都是n-1个。 smartpca的输入文件支持5种格式，可以用EIGENSOFT软件包中的convertf程序相互转换。其中最通用，最方便我们使用的就是PLINK的ped格式文件。smartpca软件运行命令行： 1smartpca -p smartpca.par &gt; pca.log smartpca.par为参数配置文件，示例如下： 12345678genotypename: sample159.pedsnpname: sample159.pedsnpindivname: sample159.pedindevecoutname: sample159.pca.vecevaloutname: sample159.pca.valnumoutlieriter: 0poplistname: popsnumchrom: 22 其中sample159.ped为PLINK格式ped文件，注意smartpca从该文件第6列读取群体信息，如果用vcftools转为PLINK格式ped文件，该列默认为-9，如果有群体信息，将该列改为相应的群体ID，如果没有，请将该列改为‘1’，如果该列为’0’, ‘9’, ‘-9’则表示过滤掉相应个体。sample159.pedsnp为PLINK格式map文件，sample159.pedind文件为sample159.ped文件的1～6列。注意，这3个文件的后缀不能改变，smartpca从文件后缀判断文件格式。*.vec和 *.val为特征向量和特征值的输出文件，numoutlieriter参数表示进行几次异常样本去除。如果只想用一部分群体进行PCA分析，将另外的个体映射到该变量空间，可以将进行PCA分析的群体ID放在poplistname参数的文件中，每个群体ID一行，其它个体将影射到这些群体的变量空间。numchrom为最大常染色体编号，超过该值的其它染色体将忽略。 smartpca程序分析结束后，就可以用特征向量*.vec文件进行画图。该文件特征向量按解释度大小从左到右排列。一般用前3个主成分进行画图展示。 主成分分析判断群体结构 主成分分析的结果可以用来判断是否存在群体结构（分层），如果亚群之间的差异比较大，我们可以看到不同的亚群会形成各自的cluster，如上图。有些群体可能差异比较小，很难通过眼睛判断是否存在群体结构，那么是否有定量的检验方法呢？ smartpca提供Tracy-Widom检验来判断在每一个主成分上是否群体存在显著分层，该检验的P值输出在log文件中。一般两个群体之间的Fst大于0.005时，Tracy-Widom检验就会十分显著。 主成分分析推断群体历史 admixture事件 如下图，如果A群体和B群体混合生成了C群体，那么PCA分析结果中，C群体会在AB的连线上，谁的比例多，离谁更近。但是如果该混合事件发生在很久以前，由于混合群体经历了自己特有的遗传漂变，会逐渐偏离该连线。 混合事件不会改变变量空间，即上面的ABCD群体和ABD群体进行PCA分析，所得到的显著主成分一样多。 migration事件 如果PCA呈线性分布，与群体的地理分布距离一致，那很有可能说明了该物种的迁徙历史。如下图，左下方彩色的点表示的是狗，该分布就呈线性，与狗从亚洲东南部，经过中亚向欧洲扩散的历史相吻合。 下图用撒哈拉以南的非洲人群体作为变量空间进行PCA分析，将其它人群体映射到该变量空间，发现所有其它非撒哈拉以南非洲人群体都聚在一起，暗示了人类从南非的一次迁出。 需要注意的是，PCA呈线性分布并非一定是migration造成的，isolation by distance也会形成该结构。所以要结合其它分析进行判断。 长的LD片段会影响PCA分析，因此高密度的SNP数据，需要进行LD过滤（LD-based SNP Prunning）。 利用PCA结果对关联分析进行群体结构校正 一般用前几个主成分进行校正，关联分析软件GAPIT可以实现，在以后GWAS专题会总结，这里不细说。 需要注意的是，用PCA进行校正的时候，最好只用与表型相关的主成分校正，不然很容易校正过度，导致模型失去power。 参考文献： Principal component analysis of genetic data Population Structure and Eigenanalysis Interpreting principal component analyses of spatialpopulation genetic variation Out of southern East Asia: the natural history of domesticdogs across the world]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分染色体并行计算中科学分配任务]]></title>
      <url>%2Fprogramming%2Fsplit-ref.html</url>
      <content type="text"><![CDATA[在生物信息分析过程中，为了加快运行速度，我们经常会采用分染色体计算的方式，即scatter/gather的思想。比如SNP calling, SNP phasing及imputation等。但怎样划分染色体，划分几个部分比较合适呢？ 一般情况下，程序运行的时间和染色体长度成正比，而组装出来的染色体一般长度差异很大。在计算资源充足的情况下，一条染色体一个任务通常是最快的。如果任务存在排队，包含长染色体的任务如果排在后面，那需要的时间反而更多了。之前供职的公司，流程采用随机分成染色体数目相等的N份，但存在一些问题：1）N为多少合适？多了如果任务有排队，一条染色体一个任务不一定快，还比较浪费计算资源。分太少又需要更多计算时间。2）随机分配，很有可能将两条较长的染色体分在一个任务中。 很多人想到了，既然程序运行时间和染色体长度成正比，那保证每份任务所分配的染色体总长相等不就可以了吗？确实是这样，这里有一个前提，即染色体不能打断，因为打断后，有些计算可能出问题，比如断点处存在变异，比如计算ROH、IBD等。 这里提供一种比较科学的解决办法：将该问题视为简单的一维装箱问题，箱子的大小即最长染色体的长度，利用贪婪算法解决这个装箱问题。如果最长的染色体计算时间是最长的，这样其它任务都不会超过这个时间，而且保证了分配的任务数量相对少（贪婪算法的结果很有可能不是全局最优解，但是好在算法简单，相对最优的结果也可以接受）。python实现如下： 123456789101112131415161718192021222324252627282930def SplitFai(fai, outdir, size=0): chrs = [] flist = [] for line in open(fai): info = line.strip().split()[0:2] chrs += [[info[0], int(info[1])]] chrs = sorted(chrs, key=lambda a: a[1], reverse=True) if not size: size = chrs[0][1] elif size &lt; chrs[0][1]: sys.stderr.write('Error: size is short than the longest chromosome!') sys.exit(0) count = 0 while chrs: fo = open(outdir+'/gemone.split_'+str(count)+'.list', 'w') flist.append(outdir+'/gemone.split_'+str(count)+'.list') lenC = 0 chrs_new = [] for each in chrs: if size - lenC &gt;= each[1]: fo.write(each[0] + '\n') lenC += each[1] else: chrs_new += [each] chrs = chrs_new count += 1 return flist 该函数有3个参数，第1个是参考序列的index文件，用samtools faidx ref.fa生成，该文件第一列为染色体名，第二列为染色体长度。第2个参数为输出目录，第3个参数为每份染色体总长度的上限，即箱子大小，默认为最长染色体长度。 注意，如果自己指定箱子大小，箱子大小必须超过最长染色体长度。 输出文件为每份包含的染色体ID。 该函数的思路：将所有染色体按照长度从大到小排序。装箱的时候先尽量装大的，直到装不下再换新箱子。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单体型网络（Haplotype Network）构建及展示]]></title>
      <url>%2FPopulation-Genetics%2Fhaplotype-network.html</url>
      <content type="text"><![CDATA[单体型网络（Haplotype Network）是谱系地理研究的重要手段。通过单体型网络，我们可以推断群体的起源、扩散历史。那么怎样理解单体型网络以及怎样构建单体型网络？ 什么是单体型网络？单体型（haplotype）在单体型网络中是指一段遗传连锁的核酸序列。不同的单体型，通过序列中的变异来区分（常用SNP）。一般用来进行单体型网络构建的单体型有：1）线粒体基因组；2）Y染色体；3）叶绿体基因组；4）基因组上一段强连锁的区段。 上图是一个单体型网络的例子，图中一个圆圈表示一个单体型，两个圆圈之间的连线表示这两个单体型相关（一个是由另一个突变而来），连线上面的短竖线表示从一个单体型到与其相连的单体型需要经历的碱基替换数，一个竖线表示一个替换。彩色的圆圈表示我们实际取样到的单体型，圆圈大小表示这种单体型的个数。灰色圆圈表示推断出来可能存在的中间单体型，没有被取样到。一种颜色一般表示一个群体，如按地理划分，品种划分等。图中例子一个单体型只存在于一个群体中，实际情况一个单体型往往在多个群体中出现。此时，一个单体型圆圈中填充多种颜色，以饼图的形式展示。从上图我们可以猜测一种可能的群体历史：A群体和C群体都起源于B群体，A群体从B群体分化出来后，经历过急剧的群体扩张，导致A群体的单体型演化出多个亚型。当然，为了避免过度解读，推断群体历史需要多种证据结合起来。 构建单体型网络的工具比较经典的软件就是Network了，但是该软件只支持Windows系统，用起来也比较复杂。这里推荐PopART，该软件支持Windows，Mac，Linux系统，而且用起来也非常方便，支持多种常用的Network构建方法，关键是该软件支持地图的形式展示单体型分布。下面简单介绍一下该软件的使用方法。PopART的输入文件格式为NEXUS，一般主要用到两个部分DATA和TRAITS。 1234567891011121314151617181920212223242526#NEXUSbegin data;dimensions ntax=4 nchar=30;format datatype=dna missing=N gap=-;matrixseq1 CCACCGTTGCTAAAAATTCATGACACAAGGseq2 CCACAGTTTCTAAAAATTCGTGATACAAGGseq3 CCACAGTTGCTACAAATTCATGATACAAGGseq4 CCACAGGTGCTAAAAATTCATGAAACAAGG;end;BEGIN TRAITS; Dimensions NTRAITS=5; Format labels=yes missing=? separator=Comma; TraitLatitude 53 43.6811 5.4 -25.61 -0; TraitLongitude 16.75 87.3311 26.5 134.355 -76; TraitLabels Europe Asia Africa Australia America; Matrix seq1 10,5,0,6,0 seq2 0,0,5,0,0 seq3 4,0,10,0,0 seq4 0,0,0,4,2 ;END; DATA部分主要纪录单体型信息，比较好理解。TRAITS部分主要纪录单体型来源的群体。如上所示，例子中取了来自5个大洲的样本，一共4种单体型，TRAITS纪录了每种单体型在不同大洲取样的个数，如seq1在Europe有10个，在Asia有5个等等。关键字TraitLatitude和TraitLongitude纪录5个群体取样地点的经纬度，该信息在单体型网络构建中可以不用，当需要用地图展示单体型地理分布时，需要填该信息。NEXUS文件生成后，打开PopART，通过File -&gt; Open输入NEXUS文件，然后通过菜单栏Network选择单体型网络构建算法，如常用的Median Joining Network。选择Median Joining Network后，会提示填写Epsilon参数，该参数用来控制推断中间单体型的细节程度，该值越大，会展示更多推断的中间单体型，一般选择默认的0就好。填好该参数后，点击OK，就生成了我们需要的单体型网络。然后通过菜单栏Edit下的选项，对图中群体的颜色、字体、图例等进行调整。下面介绍一下PopART的单体型地理分布展示。 点击View -&gt; Switch to map view就可以得到如上所示的单体型地理分布图。通过单体型的地理分布直观展示，我们就可以对群体的扩散迁徙途径进行推断。 单体型序列的获得像线粒体、叶绿体、Y染色体等这些在遗传过程中不发生重组的序列，我们直接把检测到的变异替换到参考序列中，就可以用于单体型网络构建。但是通常研究的二倍体基因组数据，由于存在重组，因此不能简单的拿一段序列就进行单体型网络构建，这样的单体型网络就失去了它本身的意义。如要用基因组上面的序列，可以通过以下步骤： 找到基因组上强连锁的区段； 对这段区域中的SNP进行phase； 第一步可以用PLINK，命令如下：1plink --noweb --bfile bed_prefix --blocks no-pheno-req 该命令运行会生成.blocks.det文件，该文件纪录了强连锁区段的起止位置、所包含的SNP。接下来，我们需要对感兴趣的强连锁区域的杂合SNP进行phase，构建单体型，该步可以使用软件BEAGLE。第二步，使用BEAGLE进行phase：1java -Xss5m -Xmx4g -jar beagle.jar gt=prefix.vcf out=phased.vcf chrom=[chr]:[start]-[end]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文献速递 (2017年4月)]]></title>
      <url>%2Fpaper-express%2Fpaper-express-201704.html</url>
      <content type="text"><![CDATA[The Rice Paradox: Multiple Origins but Single Domestication in Asian RiceMol Biol Evol (2017) 34 (4): 969-979.通过对几种栽培水稻和野生祖先的基因组比较，发现不同栽培稻亚种分别来自不同的野生祖先，但是只经历了一次驯化事件。最先被驯化的是O. sativa ssp. japonica，与O. rufipogon大概在∼13.1–24.1 ka前分歧。japonica与indica和aus的驯化前体存在基因流，导致后两者获得了驯化基因型。 Genome Sequencing Reveals the Origin of the Allotetraploid Arabidopsis suecicaMol Biol Evol (2017) 34 (4): 957-968.对15个异源四倍体拟南芥Arabidopsis suecica进行了重测序。发现其与多个祖先物种共享多态性，排除了单一起源。该物种大概在末次盛冰期(LGM)的东欧或欧亚大陆中部出现。还发现两个自交不亲和基因都没有功能。 Deleterious Variants in Asian Rice and the Potential Cost of DomesticationMol Biol Evol (2017) 34 (4): 908-924.通过与野生种的比较，发现驯化种积累了更多(∼3–4%)的有害SNPs。这些有害SNPs 主要集中在低重组率的区域。在受选择区域，有害SNPs的频率增加和同义SNPs相近。驯化导致水稻从异交向以自交为主转变。 A Working Model of the Deep Relationships of Diverse Modern Human Genetic Lineages Outside of Africa Mol Biol Evol (2017) 34 (4): 889-902.人类走出非洲后，目前的遗传结构是怎样建立的，一直是人类历史研究的主要兴趣点。本文作者提出了一个模型，能够很好的拟合各人群体（东亚，澳大利亚，美国本土，古欧亚大陆西部和北部）的基因型频率数据。 What is adaptation by natural selection? Perspectives of an experimental microbiologistPLoS Genet 13(4): e1006668.微生物对自然选择适应的综述。微生物实验进化学。 Evolutionary history of Tibetans inferred from whole-genome sequencing PLoS Genet 13(4): e1006675. 通过对27个藏族人的全基因组测序，揭示其群体历史和受选择基因。 The time and place of European admixture in Ashkenazi Jewish historyPLoS Genet 13(4): e1006644.推断德系犹太人的历史。用了一些新的推断方法。 RECKONER: read error corrector based on KMCBioinformatics (2017) 33 (7): 1086-1089.对测序的reads质量进行矫正。 SVScore: an impact prediction tool for structural variationBioinformatics (2017) 33 (7): 1083-1085.对SV的影响进行预测。发现高影响的SV在群体中的频率更低，说明它们受到纯化选择。SVscore对预测有害突变的效果比其他软件好。研究者还发现duplication比deletion受到更强的选择。 Fast and accurate phylogeny reconstruction using filtered spaced-word matchesBioinformatics (2017) 33 (7): 971-979.不依赖于比对的系统发育树构建。 Improved VCF normalization for accurate VCF comparisonBioinformatics (2017) 33 (7): 964-970.该工具将VCF文件中所有的变异替换到参考序列中，生成单个样本的基因组序列。再重新call variants，生成标准的格式，便于比较。［这个比较有意思，对于indel，即使同样的变异，samtools和gatk纪录的形式不同，没法比较，通过该工具可能可以解决。］ Biomartr: genomic data retrieval with RBioinformatics (2017) 33 (8): 1216-1217.用来从NCBI上面下载数据（参考序列，数据库等）的R包。 GWAlpha: genome-wide estimation of additive effects (alpha) based on trait quantile distribution from pool-sequencing experimentsBioinformatics (2017) 33 (8): 1246-1247.通过混池测序，估计加性效应值。 Human Demographic History Impacts Genetic Risk Prediction across Diverse Populations30107-6)AJHG 100, 635–649, April 6, 2017人类群体历史影响遗传风险预测。在一个群体中预测的疾病相关位点，也许并不适用于另一个群体。 De novo assembly of the Aedes aegypti genome using Hi-C yields chromosome-length scaffoldsScience 07 Apr 2017: Vol. 356, Issue 6333, pp. 92-95利用Hi-C技术辅助组装，将伊蚊基因组组装到染色体水平。 A chromosome conformation capture ordered sequence of the barley genomeNature 544, 427–433 (27 April 2017)大麦基因组发表 SynthEx: a synthetic-normal-based DNA sequencing tool for copy number alteration detection and tumor heterogeneity profilingGenome Biology 2017基于全基因组或全外显子组测序的拷贝数变异检测工具。其能力和基于芯片的软件相当，胜过其它基于测序的软件。 Ancient genomic changes associated with domestication of the horseScience 28 Apr 2017研究人员对14匹距今2000～4000年的古马进行全基因组测序，揭示马的驯化过程。 Genetic signatures of high-altitude adaptation in TibetansPNAS April 18, 2017 vol. 114 no. 16 4189-4194文章结合了3,008个藏族人7.3 M SNP 芯片数据以及7,287个非藏族东亚人数据，揭示了藏族人适应高原环境基因。 Parallel adaptive evolution of geographically distant herring populations on both sides of the North Atlantic OceanPNAS April 25, 2017 vol. 114 no. 17 E3452-E3461北大西洋鲱鱼的平行进化。 Finding a Needle in a Haystack: Distinguishing Mexican Maize Landraces Using a Small Number of SNPsFront. Genet., 18 April 2017作者通过50个样本（5个不同地方种）的50k芯片数据，筛选出了用于区分不同地方种的SNPs。“we identified 20 landrace-informative SNPs and 14 altitude-informative SNPs.” Full Chloroplast Genome Assembly of 11 Diverse Watermelon AccessionsFront. Genet., 18 April 201711个西瓜全叶绿体基因组序列。 Analytical Biases Associated with GC-Content in Molecular EvolutionFront. Genet., 15 February 2017碱基组成(GC含量)在不同位点或分类群的异质性，会使分子进化分析产生偏好性，如构建系统发育树，检测自然选择或估计密码子使用率。文章对产生偏好的原因以及避开偏好的方法进行了综述。 A genome-wide association study identifies six novel risk loci for primary biliary cholangitisNature Communications 8, Article number: 14828 (2017)全基因组关联分析鉴定6个新的原发胆汁性胆管炎风险位点。 Genome assembly with in vitro proximity ligation data and whole-genome triplication in lettuceNature Communications 8, Article number: 14953 (2017)生菜基因组，2.7 G。用in vitro proximity ligation数据锚定小scaffold。 Reconstructing the genome of the most recent common ancestor of flowering plantsNature Genetics 49, 490–496 (2017)开花植物最近共同祖先基因组构建。 Asymmetric subgenome selection and cis-regulatory divergence during cotton domesticationNature Genetics 49, 579–587 (2017)野生和栽培棉花揭示驯化过程中受选择基因。 Fast, scalable prediction of deleterious noncoding variants from functional and population genomic dataNature Genetics 49, 618–624 (2017)有害非编码突变预测。（是否适合非模式生物？） Single-molecule sequencing and chromatin conformation capture enable de novo reference assembly of the domestic goat genomeNature Genetics 49, 643–650 (2017)通过单分子测序和染色体构像捕获组装山羊基因组。 Scallop genome provides insights into evolution of bilaterian karyotype and developmentNature Ecology &amp; Evolution 1, Article number: 0120 (2017)扇贝基因组。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[判断fastq文件质量编码格式及Phred64转Phred33方法]]></title>
      <url>%2FQC%2Ffastq-phred-trans.html</url>
      <content type="text"><![CDATA[前几天有朋友从网上下载了一批fastq文件，为Phred64格式，分析之前没发现，比对的时候BWA报错了。很多人可能没有接触过老Illumina数据，不知道怎么判断编码格式，也不知道怎么转为Phred33格式，所以简单说明一下怎么判断fastq文件的质量编码方式以及怎么将Phred64编码格式转为Phred33编码格式。 Phred64/33质量编码格式区别fastq文件中，碱基质量是用ASCII字符表示。Phred64编码格式，碱基质量值为字符的十进制ASCII码减去64。同理，Phred33编码格式，碱基质量值为字符的十进制ASCII码减去33。一般碱基的质量值范围为[0, 41]，X ten之后，质量值只有(2,7,11,22,27,32,37,42)几个梯度。因此，GATK的BQSR过程对于X ten的数据可能更加重要。Phred质量值Q和出错的概率P的关系为Q = -10*lg(P)，如碱基质量值为30，表示出错的概率为0.001，碱基质量值为20，表示出错的概率为0.01。目前主流软件如BWA, GATK等都识别的是Phred33质量编码格式，如果为Phred64格式，则可能会报错，即使不报错，后续的分析也会有问题。因此，下载的数据如果不清楚编码格式，需要先判断，如果为Phred64，则需要转为Phred33格式。 判断fastq文件质量值编码格式格式判断既可以通过肉眼快速判断，也可以使用下面的脚本进行判断。如果文件少，没有编程基础，可以用快速判断的方法。利用程序判断更加准确、快速、可批量处理，因此有编程基础的人，应该尽量使用程序判断。 肉眼快速判断：质量字符有数字[0~9]的为Phred33，有小写字母[a~z]的为Phred64。通过程序：基本思路为将一定数量的reads质量值字符转为ASCII码，然后判断质量值的范围。脚本的使用方法如下，第一个参数为fastq文件，自动判断是否为压缩文件，第二个参数为用于判断的reads数，默认为1000。 1perl CheckFqQualityCode.pl prefix.fq[.gz] [1000] Phred64格式转Phred33格式Phred64格式转Phred33格式的原理很简单，只需在原有ASCII码的基础上减去64再加上33既可。大家可以自己写，也可以使用lh写的seqtk工具，使用命令：1seqtk seq -VQ64 prefix.phred64.fq.gz | gzip &gt; prefix.phred33.fq.gz]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GWAS如何确定候选区间和causal gene]]></title>
      <url>%2FGWAS%2FGWAS-candidate.html</url>
      <content type="text"><![CDATA[随着高通量测序成本的急剧下降，越来越多的GWAS研究通过全基因组重测序获得标记。全基因组重测序的高密度标记，使得通过GWAS研究快速找到causal gene甚至causal mutation成为可能。但是通过GWAS得到一个信号后，怎么确定与这个信号关联的基因呢？ 基本的思路就是找与这个信号强连锁的区域，一般来说r2大于0.6的区域视为强连锁的区域。简单粗糙的做法：我们可以通过群体的全基因组LD-decay分析，找到LD decay到r2等于0.6时所对应的距离，将GWAS超过阈值的信号前后各延伸这个距离作为候选区间。但是基因组不同区域的连锁程度差异很大，上面一刀切的做法可能使我们漏掉一些基因，或者多调查许多关联性并不强的基因。而且很多作物的连锁性很强，导致候选基因很多，这样就大大增加了工作难度。下面介绍一个非常简单高效的方法（参考文献）。 找到信号后，向前后延伸一段距离（可以根据全基因组的LD-decay水平大概估计），计算这段区域内所有标记pairwise r2，将r2大于0.6的block作为候选区间。pairwise r2可以用PLINK计算： 123plink --noweb --bfile &lt;bfile_prefix&gt; \ --chr 5 --from-bp 13641890 --to-bp 17641890 \ --matrix --r2 --out &lt;out_prefix&gt; 画图用R,输入文件为plink计算的到的r2矩阵，以及标记的位置: 123456789#!/usr/bin/env Rscriptlibrary(LDheatmap)argv &lt;- commandArgs(TRUE)ldmatrix &lt;- as.matrix(read.table(argv[1],sep=' '))pos &lt;- as.numeric(unlist(read.table(argv[2], head=FALSE)))pdf(argv[3])rgb.palette &lt;- colorRampPalette(rev(c("yellow", "orange", "red")), space = "rgb")LDheatmap(ldmatrix, genetic.distances=pos, color=rgb.palette(100), flip=TRUE)dev.off() 将这个区域内的标记按照其对基因功能的影响程度分为5类： 1） 标记与性状显著关联（-log10P大于阈值），且该标记影响氨基酸编码，或者位于剪接位点；2） 标记与性状显著关联，且位于基因起始密码子上游2 kb内；3） 标记与性状显著关联，且位于基因内，除开1）和2）之外的标记4） 标记与性状显著关联，位于基因间区5） 标记与性状不显著关联 然后，按照这5类的顺序，依次调查，一般来说，属于1）类的可能性很大，而且基因一般就几个，这样就大大减少了工作难度。]]></content>
    </entry>

    
  
  
</search>
